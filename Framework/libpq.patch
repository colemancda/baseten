Binary files postgresql-8.2.3/src/include/.postgres_ext.h.swp and postgresql-8.2.3-tsnorri/src/include/.postgres_ext.h.swp differ
diff -urN postgresql-8.2.3/src/include/libpq/pqcomm.h postgresql-8.2.3-tsnorri/src/include/libpq/pqcomm.h
--- postgresql-8.2.3/src/include/libpq/pqcomm.h	2006-06-08 01:24:45.000000000 +0300
+++ postgresql-8.2.3-tsnorri/src/include/libpq/pqcomm.h	2007-03-05 16:55:06.000000000 +0200
@@ -147,19 +147,6 @@
 #define MAX_STARTUP_PACKET_LENGTH 10000
 
 
-/* These are the authentication request codes sent by the backend. */
-
-#define AUTH_REQ_OK			0	/* User is authenticated  */
-#define AUTH_REQ_KRB4		1	/* Kerberos V4. Not supported any more. */
-#define AUTH_REQ_KRB5		2	/* Kerberos V5 */
-#define AUTH_REQ_PASSWORD	3	/* Password */
-#define AUTH_REQ_CRYPT		4	/* crypt password */
-#define AUTH_REQ_MD5		5	/* md5 password */
-#define AUTH_REQ_SCM_CREDS	6	/* transfer SCM credentials */
-
-typedef uint32 AuthRequest;
-
-
 /*
  * A client can also send a cancel-current-operation request to the postmaster.
  * This is uglier than sending it directly to the client's backend, but it
diff -urN postgresql-8.2.3/src/interfaces/libpq/blibpqdll.def postgresql-8.2.3-tsnorri/src/interfaces/libpq/blibpqdll.def
--- postgresql-8.2.3/src/interfaces/libpq/blibpqdll.def	2007-02-07 06:44:09.000000000 +0200
+++ postgresql-8.2.3-tsnorri/src/interfaces/libpq/blibpqdll.def	2007-03-05 16:55:07.000000000 +0200
@@ -137,6 +137,8 @@
     _PQdescribePortal          @ 134
     _PQsendDescribePrepared    @ 135
     _PQsendDescribePortal      @ 136
+    _PQauthRequest             @ 137
+    _PQerrorCode               @ 138
 
 ; Aliases for MS compatible names
     PQconnectdb               = _PQconnectdb
@@ -275,3 +277,5 @@
     PQdescribePortal          = _PQdescribePortal
     PQsendDescribePrepared    = _PQsendDescribePrepared
     PQsendDescribePortal      = _PQsendDescribePortal
+    PQauthRequest             = _PQauthRequest
+    PQerrorCode               = _PQerrorCode
diff -urN postgresql-8.2.3/src/interfaces/libpq/exports.txt postgresql-8.2.3-tsnorri/src/interfaces/libpq/exports.txt
--- postgresql-8.2.3/src/interfaces/libpq/exports.txt	2006-08-18 22:52:39.000000000 +0300
+++ postgresql-8.2.3-tsnorri/src/interfaces/libpq/exports.txt	2007-03-05 16:55:07.000000000 +0200
@@ -136,3 +136,5 @@
 PQdescribePortal          134
 PQsendDescribePrepared    135
 PQsendDescribePortal      136
+PQauthRequest             137
+PQerrorCode               138
diff -urN postgresql-8.2.3/src/interfaces/libpq/fe-connect.c postgresql-8.2.3-tsnorri/src/interfaces/libpq/fe-connect.c
--- postgresql-8.2.3/src/interfaces/libpq/fe-connect.c	2006-11-21 18:28:00.000000000 +0200
+++ postgresql-8.2.3-tsnorri/src/interfaces/libpq/fe-connect.c	2007-03-05 16:56:02.000000000 +0200
@@ -998,6 +998,8 @@
 
 			/* Special cases: proceed without waiting. */
 		case CONNECTION_SSL_STARTUP:
+        case CONNECTION_SSL_CONTINUE:
+        case CONNECTION_AUTH_START:
 		case CONNECTION_NEEDED:
 			break;
 
@@ -1305,13 +1307,17 @@
 		case CONNECTION_SSL_STARTUP:
 			{
 #ifdef USE_SSL
-				PostgresPollingStatusType pollres;
-
 				/*
 				 * On first time through, get the postmaster's response to our
 				 * SSL negotiation packet.
 				 */
-				if (conn->ssl == NULL)
+				if (conn->ssl != NULL)
+                {
+                    /* We shouldn't end up here */
+                    conn->status = CONNECTION_SSL_CONTINUE;
+                    return PGRES_POLLING_WRITING;
+                }
+                else
 				{
 					/*
 					 * We use pqReadData here since it has the logic to
@@ -1344,6 +1350,9 @@
 						/* Do one-time setup; this creates conn->ssl */
 						if (pqsecure_initialize(conn) == -1)
 							goto error_return;
+
+                        conn->status = CONNECTION_SSL_CONTINUE;
+                        return pqsecure_prepare_client (conn);
 					}
 					else if (SSLok == 'N')
 					{
@@ -1390,10 +1399,18 @@
 					}
 				}
 
+#else							/* !USE_SSL */
+				/* can't get here */
+				goto error_return;
+#endif   /* USE_SSL */
+            }
+        case CONNECTION_SSL_CONTINUE:
+            {
+#ifdef USE_SSL
 				/*
 				 * Begin or continue the SSL negotiation process.
 				 */
-				pollres = pqsecure_open_client(conn);
+				PostgresPollingStatusType pollres = pqsecure_open_client(conn);
 				if (pollres == PGRES_POLLING_OK)
 				{
 					/* SSL handshake done, ready to send startup packet */
@@ -1435,7 +1452,6 @@
 				char		beresp;
 				int			msgLength;
 				int			avail;
-				AuthRequest areq;
 
 				/*
 				 * Scan the message from current point (note that if we find
@@ -1622,14 +1638,24 @@
 
 				/* It is an authentication request. */
 				/* Get the type of request. */
-				if (pqGetInt((int *) &areq, 4, conn))
+                /* If credentials are needed but haven't been supplied, return. */
+				if (pqGetInt((int *) &conn->areq, 4, conn))
 				{
 					/* We'll come back when there are more data */
 					return PGRES_POLLING_READING;
 				}
+                else if (AUTH_REQ_OK != conn->areq && NULL == conn->pguser)
+                {
+                    conn->status = CONNECTION_AUTH_START;
+                    return PGRES_POLLING_ACTIVE;
+                }
+	            /* Otherwise fall through. */
+    		}
 
+        case CONNECTION_AUTH_START:
+            {
 				/* Get the password salt if there is one. */
-				if (areq == AUTH_REQ_MD5)
+				if (conn->areq == AUTH_REQ_MD5)
 				{
 					if (pqGetnchar(conn->md5Salt,
 								   sizeof(conn->md5Salt), conn))
@@ -1638,7 +1664,7 @@
 						return PGRES_POLLING_READING;
 					}
 				}
-				if (areq == AUTH_REQ_CRYPT)
+				if (conn->areq == AUTH_REQ_CRYPT)
 				{
 					if (pqGetnchar(conn->cryptSalt,
 								   sizeof(conn->cryptSalt), conn))
@@ -1664,10 +1690,11 @@
 				 * XXX fe-auth.c has not been fixed to support PQExpBuffers,
 				 * so:
 				 */
-				if (pg_fe_sendauth(areq, conn, conn->pghost, conn->pgpass,
+				if (pg_fe_sendauth(conn->areq, conn, conn->pghost, conn->pgpass,
 								   conn->errorMessage.data) != STATUS_OK)
 				{
 					conn->errorMessage.len = strlen(conn->errorMessage.data);
+                    conn->errorCode = PGCONN_AUTH_FAILURE;
 					goto error_return;
 				}
 				conn->errorMessage.len = strlen(conn->errorMessage.data);
@@ -1680,7 +1707,7 @@
 				if (pqFlush(conn))
 					goto error_return;
 
-				if (areq == AUTH_REQ_OK)
+				if (conn->areq == AUTH_REQ_OK)
 				{
 					/* We are done with authentication exchange */
 					conn->status = CONNECTION_AUTH_OK;
@@ -1725,6 +1752,8 @@
 					if (res->resultStatus != PGRES_FATAL_ERROR)
 						printfPQExpBuffer(&conn->errorMessage,
 										  libpq_gettext("unexpected message from server during startup\n"));
+                    else
+                        conn->errorCode = PGCONN_AUTH_FAILURE;
 
 					/*
 					 * if the resultStatus is FATAL, then conn->errorMessage
@@ -1857,6 +1886,8 @@
 	conn->std_strings = false;	/* unless server says differently */
 	conn->verbosity = PQERRORS_DEFAULT;
 	conn->sock = -1;
+    conn->areq = '\0';
+    conn->errorCode = PGCONN_NO_ERROR;
 #ifdef USE_SSL
 	conn->allow_ssl_try = true;
 	conn->wait_ssl_try = false;
@@ -3305,6 +3336,14 @@
 	return conn->status;
 }
 
+PGConnectionErrorCode
+PQerrorCode(const PGconn *conn)
+{
+    if (!conn)
+        return PGCONN_NO_ERROR;
+    return conn->errorCode;
+}
+
 PGTransactionStatusType
 PQtransactionStatus(const PGconn *conn)
 {
@@ -3492,6 +3531,12 @@
 	return old;
 }
 
+AuthRequest
+PQauthRequest(PGconn *conn)
+{
+    return conn->areq;
+}
+
 /*
  * The default notice message receiver just gets the standard notice text
  * and sends it to the notice processor.  This two-level setup exists
diff -urN postgresql-8.2.3/src/interfaces/libpq/fe-protocol3.c postgresql-8.2.3-tsnorri/src/interfaces/libpq/fe-protocol3.c
--- postgresql-8.2.3/src/interfaces/libpq/fe-protocol3.c	2006-10-04 03:30:13.000000000 +0300
+++ postgresql-8.2.3-tsnorri/src/interfaces/libpq/fe-protocol3.c	2007-03-05 18:50:45.000000000 +0200
@@ -847,6 +847,11 @@
 	 */
 	if (isError)
 	{
+        char* sqlState = PQresultErrorField (res, PG_DIAG_SQLSTATE);
+        //FIXME: the different states should be inside a switch statement but this is a hack anyway.
+        if (0 == strcmp ("28000", sqlState))
+            conn->errorCode = PGCONN_AUTH_FAILURE;
+
 		res->errMsg = pqResultStrdup(res, workBuf.data);
 		if (!res->errMsg)
 			goto fail;
diff -urN postgresql-8.2.3/src/interfaces/libpq/fe-secure.c postgresql-8.2.3-tsnorri/src/interfaces/libpq/fe-secure.c
--- postgresql-8.2.3/src/interfaces/libpq/fe-secure.c	2006-10-06 20:14:01.000000000 +0300
+++ postgresql-8.2.3-tsnorri/src/interfaces/libpq/fe-secure.c	2007-03-05 16:55:07.000000000 +0200
@@ -193,10 +193,10 @@
 }
 
 /*
- *	Attempt to negotiate secure session.
+ *  Set conn->ssl.
  */
 PostgresPollingStatusType
-pqsecure_open_client(PGconn *conn)
+pqsecure_prepare_client(PGconn *conn)
 {
 #ifdef USE_SSL
 	/* First time through? */
@@ -221,7 +221,21 @@
 		 * detect whether client_cert_cb() has stored a message.
 		 */
 		resetPQExpBuffer(&conn->errorMessage);
-	}
+    }
+    return PGRES_POLLING_ACTIVE;
+#else
+	/* shouldn't get here */
+	return PGRES_POLLING_FAILED;
+#endif
+}
+
+/*
+ *	Attempt to negotiate secure session.
+ */
+PostgresPollingStatusType
+pqsecure_open_client(PGconn *conn)
+{
+#ifdef USE_SSL
 	/* Begin or continue the actual handshake */
 	return open_client_SSL(conn);
 #else
diff -urN postgresql-8.2.3/src/interfaces/libpq/libpq-fe.h postgresql-8.2.3-tsnorri/src/interfaces/libpq/libpq-fe.h
--- postgresql-8.2.3/src/interfaces/libpq/libpq-fe.h	2006-10-04 03:30:13.000000000 +0300
+++ postgresql-8.2.3-tsnorri/src/interfaces/libpq/libpq-fe.h	2007-03-05 16:55:07.000000000 +0200
@@ -53,11 +53,19 @@
 								 * backend startup. */
 	CONNECTION_SETENV,			/* Negotiating environment. */
 	CONNECTION_SSL_STARTUP,		/* Negotiating SSL. */
-	CONNECTION_NEEDED			/* Internal state: connect() needed */
+	CONNECTION_NEEDED,			/* Internal state: connect() needed */
+    CONNECTION_SSL_CONTINUE,
+    CONNECTION_AUTH_START
 } ConnStatusType;
 
 typedef enum
 {
+    PGCONN_NO_ERROR = 0,
+    PGCONN_AUTH_FAILURE
+} PGConnectionErrorCode;
+
+typedef enum
+{
 	PGRES_POLLING_FAILED = 0,
 	PGRES_POLLING_READING,		/* These two indicate that one may	  */
 	PGRES_POLLING_WRITING,		/* use select before polling again.   */
@@ -99,6 +107,20 @@
 	PQERRORS_VERBOSE			/* all the facts, ma'am */
 } PGVerbosity;
 
+
+/* These are the authentication request codes sent by the backend. */
+typedef enum
+{
+    AUTH_REQ_OK = 0,	/* User is authenticated  */
+    AUTH_REQ_KRB4,      /* Kerberos V4. Not supported any more. */
+    AUTH_REQ_KRB5,      /* Kerberos V5 */
+    AUTH_REQ_PASSWORD,  /* Password */
+    AUTH_REQ_CRYPT,     /* crypt password */
+    AUTH_REQ_MD5,       /* md5 password */
+    AUTH_REQ_SCM_CREDS  /* transfer SCM credentials */
+} AuthRequest;
+
+
 /* PGconn encapsulates a connection to the backend.
  * The contents of this struct are not supposed to be known to applications.
  */
@@ -265,6 +287,8 @@
 extern int	PQbackendPID(const PGconn *conn);
 extern int	PQclientEncoding(const PGconn *conn);
 extern int	PQsetClientEncoding(PGconn *conn, const char *encoding);
+extern AuthRequest PQauthRequest(PGconn *conn);
+extern PGConnectionErrorCode PQerrorCode(const PGconn *conn);
 
 /* Get the OpenSSL structure associated with a connection. Returns NULL for
  * unencrypted connections or if any other TLS library is in use. */
diff -urN postgresql-8.2.3/src/interfaces/libpq/libpq-int.h postgresql-8.2.3-tsnorri/src/interfaces/libpq/libpq-int.h
--- postgresql-8.2.3/src/interfaces/libpq/libpq-int.h	2006-10-04 03:30:13.000000000 +0300
+++ postgresql-8.2.3-tsnorri/src/interfaces/libpq/libpq-int.h	2007-03-05 16:55:07.000000000 +0200
@@ -284,6 +284,7 @@
 
 	/* Status indicators */
 	ConnStatusType status;
+    PGConnectionErrorCode errorCode;
 	PGAsyncStatusType asyncStatus;
 	PGTransactionStatusType xactStatus; /* never changes to ACTIVE */
 	PGQueryClass queryclass;
@@ -310,6 +311,7 @@
 	int			addrlist_family;	/* needed to know how to free addrlist */
 	PGSetenvStatusType setenv_state;	/* for 2.0 protocol only */
 	const PQEnvironmentOption *next_eo;
+    AuthRequest areq;
 
 	/* Miscellaneous stuff */
 	int			be_pid;			/* PID of backend --- needed for cancels */
@@ -485,6 +487,7 @@
 
 extern int	pqsecure_initialize(PGconn *);
 extern void pqsecure_destroy(void);
+extern PostgresPollingStatusType pqsecure_prepare_client(PGconn *);
 extern PostgresPollingStatusType pqsecure_open_client(PGconn *);
 extern void pqsecure_close(PGconn *);
 extern ssize_t pqsecure_read(PGconn *, void *ptr, size_t len);
diff -urN postgresql-8.2.3/src/interfaces/libpq/libpqddll.def postgresql-8.2.3-tsnorri/src/interfaces/libpq/libpqddll.def
--- postgresql-8.2.3/src/interfaces/libpq/libpqddll.def	2007-02-07 06:44:09.000000000 +0200
+++ postgresql-8.2.3-tsnorri/src/interfaces/libpq/libpqddll.def	2007-03-05 16:55:07.000000000 +0200
@@ -137,3 +137,5 @@
     PQdescribePortal          @ 134
     PQsendDescribePrepared    @ 135
     PQsendDescribePortal      @ 136
+    PQauthRequest             @ 137
+    PQerrorCode               @ 138
diff -urN postgresql-8.2.3/src/interfaces/libpq/libpqdll.def postgresql-8.2.3-tsnorri/src/interfaces/libpq/libpqdll.def
--- postgresql-8.2.3/src/interfaces/libpq/libpqdll.def	2007-02-07 06:44:09.000000000 +0200
+++ postgresql-8.2.3-tsnorri/src/interfaces/libpq/libpqdll.def	2007-03-05 16:55:07.000000000 +0200
@@ -137,3 +137,5 @@
     PQdescribePortal          @ 134
     PQsendDescribePrepared    @ 135
     PQsendDescribePortal      @ 136
+    PQauthRequest             @ 137
+    PQerrorCode               @ 138
diff -urN postgresql-8.2.3/src/interfaces/libpq/result postgresql-8.2.3-tsnorri/src/interfaces/libpq/result
--- postgresql-8.2.3/src/interfaces/libpq/result	1970-01-01 02:00:00.000000000 +0200
+++ postgresql-8.2.3-tsnorri/src/interfaces/libpq/result	2007-03-05 18:40:41.000000000 +0200
@@ -0,0 +1,1094 @@
+fe-auth.c:	if (sendmsg(conn->sock, &msg, 0) == -1)
+fe-auth.c:				if (!pg_md5_encrypt(password, conn->pguser,
+fe-auth.c:									strlen(conn->pguser), crypt_pwd2))
+fe-auth.c:				if (!pg_md5_encrypt(crypt_pwd2 + strlen("md5"), conn->md5Salt,
+fe-auth.c:									sizeof(conn->md5Salt), crypt_pwd))
+fe-auth.c:				StrNCpy(salt, conn->cryptSalt, 3);
+fe-auth.c:	if (PG_PROTOCOL_MAJOR(conn->pversion) >= 3)
+fe-auth.c:			if (pg_krb5_sendauth(PQerrormsg, conn->sock,
+fe-auth.c:								 hostname, conn->krbsrvname) != STATUS_OK)
+fe-connect.c:	if (conn && conn->status != CONNECTION_BAD)
+fe-connect.c:		conn->status = CONNECTION_BAD;
+fe-connect.c: * and so is conn->status).
+fe-connect.c:	connOptions = conninfo_parse(conninfo, &conn->errorMessage);
+fe-connect.c:		conn->status = CONNECTION_BAD;
+fe-connect.c:	conn->pghostaddr = tmp ? strdup(tmp) : NULL;
+fe-connect.c:	conn->pghost = tmp ? strdup(tmp) : NULL;
+fe-connect.c:	conn->pgport = tmp ? strdup(tmp) : NULL;
+fe-connect.c:	conn->pgtty = tmp ? strdup(tmp) : NULL;
+fe-connect.c:	conn->pgoptions = tmp ? strdup(tmp) : NULL;
+fe-connect.c:	conn->dbName = tmp ? strdup(tmp) : NULL;
+fe-connect.c:	conn->pguser = tmp ? strdup(tmp) : NULL;
+fe-connect.c:	conn->pgpass = tmp ? strdup(tmp) : NULL;
+fe-connect.c:	conn->connect_timeout = tmp ? strdup(tmp) : NULL;
+fe-connect.c:	conn->sslmode = tmp ? strdup(tmp) : NULL;
+fe-connect.c:		if (conn->sslmode)
+fe-connect.c:			free(conn->sslmode);
+fe-connect.c:		conn->sslmode = strdup("require");
+fe-connect.c:	conn->krbsrvname = tmp ? strdup(tmp) : NULL;
+fe-connect.c: * and so is conn->status).
+fe-connect.c:	if ((conn->dbName == NULL || conn->dbName[0] == '\0')
+fe-connect.c:		&& conn->pguser != NULL)
+fe-connect.c:		if (conn->dbName)
+fe-connect.c:			free(conn->dbName);
+fe-connect.c:		conn->dbName = strdup(conn->pguser);
+fe-connect.c:	if (conn->pgpass == NULL || conn->pgpass[0] == '\0')
+fe-connect.c:		if (conn->pgpass)
+fe-connect.c:			free(conn->pgpass);
+fe-connect.c:		conn->pgpass = PasswordFromFile(conn->pghost, conn->pgport,
+fe-connect.c:										conn->dbName, conn->pguser);
+fe-connect.c:		if (conn->pgpass == NULL)
+fe-connect.c:			conn->pgpass = strdup(DefaultPassword);
+fe-connect.c:	if (conn->pghost && is_absolute_path(conn->pghost))
+fe-connect.c:		if (conn->pgunixsocket)
+fe-connect.c:			free(conn->pgunixsocket);
+fe-connect.c:		conn->pgunixsocket = conn->pghost;
+fe-connect.c:		conn->pghost = NULL;
+fe-connect.c:	if (conn->sslmode)
+fe-connect.c:		if (strcmp(conn->sslmode, "disable") != 0
+fe-connect.c:			&& strcmp(conn->sslmode, "allow") != 0
+fe-connect.c:			&& strcmp(conn->sslmode, "prefer") != 0
+fe-connect.c:			&& strcmp(conn->sslmode, "require") != 0)
+fe-connect.c:			conn->status = CONNECTION_BAD;
+fe-connect.c:			printfPQExpBuffer(&conn->errorMessage,
+fe-connect.c:							  conn->sslmode);
+fe-connect.c:		switch (conn->sslmode[0])
+fe-connect.c:				conn->status = CONNECTION_BAD;
+fe-connect.c:				printfPQExpBuffer(&conn->errorMessage,
+fe-connect.c:								  conn->sslmode);
+fe-connect.c:		conn->sslmode = strdup(DefaultSSLMode);
+fe-connect.c:	conn->options_valid = true;
+fe-connect.c:		if (conn->pghost)
+fe-connect.c:			free(conn->pghost);
+fe-connect.c:		conn->pghost = strdup(pghost);
+fe-connect.c:		if (conn->pgport)
+fe-connect.c:			free(conn->pgport);
+fe-connect.c:		conn->pgport = strdup(pgport);
+fe-connect.c:		if (conn->pgoptions)
+fe-connect.c:			free(conn->pgoptions);
+fe-connect.c:		conn->pgoptions = strdup(pgoptions);
+fe-connect.c:		if (conn->pgtty)
+fe-connect.c:			free(conn->pgtty);
+fe-connect.c:		conn->pgtty = strdup(pgtty);
+fe-connect.c:		if (conn->dbName)
+fe-connect.c:			free(conn->dbName);
+fe-connect.c:		conn->dbName = strdup(dbName);
+fe-connect.c:		if (conn->pguser)
+fe-connect.c:			free(conn->pguser);
+fe-connect.c:		conn->pguser = strdup(login);
+fe-connect.c:		if (conn->pgpass)
+fe-connect.c:			free(conn->pgpass);
+fe-connect.c:		conn->pgpass = strdup(pwd);
+fe-connect.c:	if (setsockopt(conn->sock, IPPROTO_TCP, TCP_NODELAY,
+fe-connect.c:		printfPQExpBuffer(&conn->errorMessage,
+fe-connect.c:	if (IS_AF_UNIX(conn->raddr.addr.ss_family))
+fe-connect.c:		pg_getnameinfo_all(&conn->raddr.addr, conn->raddr.salen,
+fe-connect.c:		printfPQExpBuffer(&conn->errorMessage,
+fe-connect.c:		printfPQExpBuffer(&conn->errorMessage,
+fe-connect.c:						  conn->pghostaddr
+fe-connect.c:						  ? conn->pghostaddr
+fe-connect.c:						  : (conn->pghost
+fe-connect.c:							 ? conn->pghost
+fe-connect.c:						  conn->pgport);
+fe-connect.c:	if (!conn->options_valid)
+fe-connect.c:	conn->inStart = conn->inCursor = conn->inEnd = 0;
+fe-connect.c:	conn->outCount = 0;
+fe-connect.c:	if (conn->pgport != NULL && conn->pgport[0] != '\0')
+fe-connect.c:		portnum = atoi(conn->pgport);
+fe-connect.c:	if (conn->pghostaddr != NULL && conn->pghostaddr[0] != '\0')
+fe-connect.c:		node = conn->pghostaddr;
+fe-connect.c:	else if (conn->pghost != NULL && conn->pghost[0] != '\0')
+fe-connect.c:		node = conn->pghost;
+fe-connect.c:		UNIXSOCK_PATH(portstr, portnum, conn->pgunixsocket);
+fe-connect.c:			printfPQExpBuffer(&conn->errorMessage,
+fe-connect.c:			printfPQExpBuffer(&conn->errorMessage,
+fe-connect.c:	if (conn->sslmode[0] == 'd')	/* "disable" */
+fe-connect.c:		conn->allow_ssl_try = false;
+fe-connect.c:	else if (conn->sslmode[0] == 'a')	/* "allow" */
+fe-connect.c:		conn->wait_ssl_try = true;
+fe-connect.c:	conn->addrlist = addrs;
+fe-connect.c:	conn->addr_cur = addrs;
+fe-connect.c:	conn->addrlist_family = hint.ai_family;
+fe-connect.c:	conn->pversion = PG_PROTOCOL(3, 0);
+fe-connect.c:	conn->status = CONNECTION_NEEDED;
+fe-connect.c:	if (conn->sock >= 0)
+fe-connect.c:		closesocket(conn->sock);
+fe-connect.c:		conn->sock = -1;
+fe-connect.c:	conn->status = CONNECTION_BAD;
+fe-connect.c:	if (conn == NULL || conn->status == CONNECTION_BAD)
+fe-connect.c:	if (conn->connect_timeout != NULL)
+fe-connect.c:		int			timeout = atoi(conn->connect_timeout);
+fe-connect.c:					conn->status = CONNECTION_BAD;
+fe-connect.c:					conn->status = CONNECTION_BAD;
+fe-connect.c:				conn->status = CONNECTION_BAD;
+fe-connect.c:	switch (conn->status)
+fe-connect.c:			printfPQExpBuffer(&conn->errorMessage,
+fe-connect.c:	switch (conn->status)
+fe-connect.c:				 * returned by pg_getaddrinfo_all().  conn->addr_cur is the
+fe-connect.c:				while (conn->addr_cur != NULL)
+fe-connect.c:					struct addrinfo *addr_cur = conn->addr_cur;
+fe-connect.c:					memcpy(&conn->raddr.addr, addr_cur->ai_addr,
+fe-connect.c:					conn->raddr.salen = addr_cur->ai_addrlen;
+fe-connect.c:					conn->sock = socket(addr_cur->ai_family, SOCK_STREAM, 0);
+fe-connect.c:					if (conn->sock < 0)
+fe-connect.c:							conn->addr_cur = addr_cur->ai_next;
+fe-connect.c:						printfPQExpBuffer(&conn->errorMessage,
+fe-connect.c:							closesocket(conn->sock);
+fe-connect.c:							conn->sock = -1;
+fe-connect.c:							conn->addr_cur = addr_cur->ai_next;
+fe-connect.c:					if (!pg_set_noblock(conn->sock))
+fe-connect.c:						printfPQExpBuffer(&conn->errorMessage,
+fe-connect.c:						closesocket(conn->sock);
+fe-connect.c:						conn->sock = -1;
+fe-connect.c:						conn->addr_cur = addr_cur->ai_next;
+fe-connect.c:					if (fcntl(conn->sock, F_SETFD, FD_CLOEXEC) == -1)
+fe-connect.c:						printfPQExpBuffer(&conn->errorMessage,
+fe-connect.c:						closesocket(conn->sock);
+fe-connect.c:						conn->sock = -1;
+fe-connect.c:						conn->addr_cur = addr_cur->ai_next;
+fe-connect.c:					if (connect(conn->sock, addr_cur->ai_addr,
+fe-connect.c:							conn->status = CONNECTION_STARTED;
+fe-connect.c:						conn->status = CONNECTION_STARTED;
+fe-connect.c:					if (conn->sock >= 0)
+fe-connect.c:						closesocket(conn->sock);
+fe-connect.c:						conn->sock = -1;
+fe-connect.c:					conn->addr_cur = addr_cur->ai_next;
+fe-connect.c:				if (getsockopt(conn->sock, SOL_SOCKET, SO_ERROR,
+fe-connect.c:					printfPQExpBuffer(&conn->errorMessage,
+fe-connect.c:					if (conn->addr_cur->ai_next != NULL)
+fe-connect.c:						if (conn->sock >= 0)
+fe-connect.c:							closesocket(conn->sock);
+fe-connect.c:							conn->sock = -1;
+fe-connect.c:						conn->addr_cur = conn->addr_cur->ai_next;
+fe-connect.c:						conn->status = CONNECTION_NEEDED;
+fe-connect.c:				conn->laddr.salen = sizeof(conn->laddr.addr);
+fe-connect.c:				if (getsockname(conn->sock,
+fe-connect.c:								(struct sockaddr *) & conn->laddr.addr,
+fe-connect.c:								&conn->laddr.salen) < 0)
+fe-connect.c:					printfPQExpBuffer(&conn->errorMessage,
+fe-connect.c:				conn->status = CONNECTION_MADE;
+fe-connect.c:				if (IS_AF_UNIX(conn->raddr.addr.ss_family))
+fe-connect.c:					conn->allow_ssl_try = false;
+fe-connect.c:				if (conn->allow_ssl_try && !conn->wait_ssl_try &&
+fe-connect.c:					conn->ssl == NULL)
+fe-connect.c:						printfPQExpBuffer(&conn->errorMessage,
+fe-connect.c:					conn->status = CONNECTION_SSL_STARTUP;
+fe-connect.c:				if (PG_PROTOCOL_MAJOR(conn->pversion) >= 3)
+fe-connect.c:					printfPQExpBuffer(&conn->errorMessage,
+fe-connect.c:					printfPQExpBuffer(&conn->errorMessage,
+fe-connect.c:				conn->status = CONNECTION_AWAITING_RESPONSE;
+fe-connect.c:				if (conn->ssl != NULL)
+fe-connect.c:                    conn->status = CONNECTION_SSL_CONTINUE;
+fe-connect.c:					 * conn->ssl isn't set, a plain recv() will occur.
+fe-connect.c:					conn->inStart = conn->inCursor;
+fe-connect.c:						/* Do one-time setup; this creates conn->ssl */
+fe-connect.c:                        conn->status = CONNECTION_SSL_CONTINUE;
+fe-connect.c:						if (conn->sslmode[0] == 'r')	/* "require" */
+fe-connect.c:							printfPQExpBuffer(&conn->errorMessage,
+fe-connect.c:						conn->allow_ssl_try = false;
+fe-connect.c:						conn->status = CONNECTION_MADE;
+fe-connect.c:						if (conn->Pfdebug)
+fe-connect.c:							fprintf(conn->Pfdebug, "received error from server, attempting fallback to pre-7.0\n");
+fe-connect.c:						if (conn->sslmode[0] == 'r')	/* "require" */
+fe-connect.c:							printfPQExpBuffer(&conn->errorMessage,
+fe-connect.c:						conn->allow_ssl_try = false;
+fe-connect.c:						conn->pversion = PG_PROTOCOL(2, 0);
+fe-connect.c:						closesocket(conn->sock);
+fe-connect.c:						conn->sock = -1;
+fe-connect.c:						conn->status = CONNECTION_NEEDED;
+fe-connect.c:						printfPQExpBuffer(&conn->errorMessage,
+fe-connect.c:					conn->status = CONNECTION_MADE;
+fe-connect.c:					if (conn->sslmode[0] == 'p' /* "prefer" */
+fe-connect.c:						&& conn->allow_ssl_try	/* redundant? */
+fe-connect.c:						&& !conn->wait_ssl_try) /* redundant? */
+fe-connect.c:						conn->allow_ssl_try = false;
+fe-connect.c:						closesocket(conn->sock);
+fe-connect.c:						conn->sock = -1;
+fe-connect.c:						conn->status = CONNECTION_NEEDED;
+fe-connect.c:				conn->inCursor = conn->inStart;
+fe-connect.c:					printfPQExpBuffer(&conn->errorMessage,
+fe-connect.c:				if (PG_PROTOCOL_MAJOR(conn->pversion) >= 3)
+fe-connect.c:					printfPQExpBuffer(&conn->errorMessage,
+fe-connect.c:					conn->inCursor = conn->inStart + 1; /* reread data */
+fe-connect.c:					if (pqGets(&conn->errorMessage, conn))
+fe-connect.c:					conn->inStart = conn->inCursor;
+fe-connect.c:					appendPQExpBufferChar(&conn->errorMessage, '\n');
+fe-connect.c:					if (PG_PROTOCOL_MAJOR(conn->pversion) >= 3)
+fe-connect.c:						conn->pversion = PG_PROTOCOL(2, 0);
+fe-connect.c:						closesocket(conn->sock);
+fe-connect.c:						conn->sock = -1;
+fe-connect.c:						conn->status = CONNECTION_NEEDED;
+fe-connect.c:				avail = conn->inEnd - conn->inCursor;
+fe-connect.c:					if (pqCheckInBufferSpace(conn->inCursor + msgLength, conn))
+fe-connect.c:					if (PG_PROTOCOL_MAJOR(conn->pversion) >= 3)
+fe-connect.c:						if (pqGets(&conn->errorMessage, conn))
+fe-connect.c:					conn->inStart = conn->inCursor;
+fe-connect.c:					if (conn->sslmode[0] == 'a' /* "allow" */
+fe-connect.c:						&& conn->ssl == NULL
+fe-connect.c:						&& conn->allow_ssl_try
+fe-connect.c:						&& conn->wait_ssl_try)
+fe-connect.c:						conn->wait_ssl_try = false;
+fe-connect.c:						closesocket(conn->sock);
+fe-connect.c:						conn->sock = -1;
+fe-connect.c:						conn->status = CONNECTION_NEEDED;
+fe-connect.c:					if (conn->sslmode[0] == 'p' /* "prefer" */
+fe-connect.c:						&& conn->ssl
+fe-connect.c:						&& conn->allow_ssl_try	/* redundant? */
+fe-connect.c:						&& !conn->wait_ssl_try) /* redundant? */
+fe-connect.c:						conn->allow_ssl_try = false;
+fe-connect.c:						closesocket(conn->sock);
+fe-connect.c:						conn->sock = -1;
+fe-connect.c:						conn->status = CONNECTION_NEEDED;
+fe-connect.c:				if (pqGetInt((int *) &conn->areq, 4, conn))
+fe-connect.c:                else if (AUTH_REQ_OK != conn->areq && NULL == conn->pguser)
+fe-connect.c:                    conn->status = CONNECTION_AUTH_START;
+fe-connect.c:				if (conn->areq == AUTH_REQ_MD5)
+fe-connect.c:					if (pqGetnchar(conn->md5Salt,
+fe-connect.c:								   sizeof(conn->md5Salt), conn))
+fe-connect.c:				if (conn->areq == AUTH_REQ_CRYPT)
+fe-connect.c:					if (pqGetnchar(conn->cryptSalt,
+fe-connect.c:								   sizeof(conn->cryptSalt), conn))
+fe-connect.c:				conn->inStart = conn->inCursor;
+fe-connect.c:				 * Note that conn->pghost must be non-NULL if we are going to
+fe-connect.c:				if (pg_fe_sendauth(conn->areq, conn, conn->pghost, conn->pgpass,
+fe-connect.c:								   conn->errorMessage.data) != STATUS_OK)
+fe-connect.c:					conn->errorMessage.len = strlen(conn->errorMessage.data);
+fe-connect.c:                    conn->errorCode = PGCONN_AUTH_FAILURE;
+fe-connect.c:				conn->errorMessage.len = strlen(conn->errorMessage.data);
+fe-connect.c:				if (conn->areq == AUTH_REQ_OK)
+fe-connect.c:					conn->status = CONNECTION_AUTH_OK;
+fe-connect.c:					conn->asyncStatus = PGASYNC_BUSY;
+fe-connect.c:						printfPQExpBuffer(&conn->errorMessage,
+fe-connect.c:                        conn->errorCode = PGCONN_AUTH_FAILURE;
+fe-connect.c:					 * if the resultStatus is FATAL, then conn->errorMessage
+fe-connect.c:					if (conn->errorMessage.len <= 0 ||
+fe-connect.c:						conn->errorMessage.data[conn->errorMessage.len - 1] != '\n')
+fe-connect.c:						appendPQExpBufferChar(&conn->errorMessage, '\n');
+fe-connect.c:				pg_freeaddrinfo_all(conn->addrlist_family, conn->addrlist);
+fe-connect.c:				conn->addrlist = NULL;
+fe-connect.c:				conn->addr_cur = NULL;
+fe-connect.c:				if (PG_PROTOCOL_MAJOR(conn->pversion) < 3)
+fe-connect.c:					conn->status = CONNECTION_SETENV;
+fe-connect.c:					conn->setenv_state = SETENV_STATE_OPTION_SEND;
+fe-connect.c:					conn->next_eo = EnvironmentOptions;
+fe-connect.c:				conn->status = CONNECTION_OK;
+fe-connect.c:			conn->status = CONNECTION_OK;
+fe-connect.c:					conn->status = CONNECTION_SETENV;
+fe-connect.c:					conn->status = CONNECTION_SETENV;
+fe-connect.c:			conn->status = CONNECTION_OK;
+fe-connect.c:			printfPQExpBuffer(&conn->errorMessage,
+fe-connect.c:							  conn->status);
+fe-connect.c:	conn->status = CONNECTION_BAD;
+fe-connect.c:	conn->noticeHooks.noticeRec = defaultNoticeReceiver;
+fe-connect.c:	conn->noticeHooks.noticeProc = defaultNoticeProcessor;
+fe-connect.c:	conn->status = CONNECTION_BAD;
+fe-connect.c:	conn->asyncStatus = PGASYNC_IDLE;
+fe-connect.c:	conn->xactStatus = PQTRANS_IDLE;
+fe-connect.c:	conn->options_valid = false;
+fe-connect.c:	conn->nonblocking = false;
+fe-connect.c:	conn->setenv_state = SETENV_STATE_IDLE;
+fe-connect.c:	conn->client_encoding = PG_SQL_ASCII;
+fe-connect.c:	conn->std_strings = false;	/* unless server says differently */
+fe-connect.c:	conn->verbosity = PQERRORS_DEFAULT;
+fe-connect.c:	conn->sock = -1;
+fe-connect.c:    conn->areq = '\0';
+fe-connect.c:    conn->errorCode = PGCONN_NO_ERROR;
+fe-connect.c:	conn->allow_ssl_try = true;
+fe-connect.c:	conn->wait_ssl_try = false;
+fe-connect.c:	conn->inBufSize = 16 * 1024;
+fe-connect.c:	conn->inBuffer = (char *) malloc(conn->inBufSize);
+fe-connect.c:	conn->outBufSize = 16 * 1024;
+fe-connect.c:	conn->outBuffer = (char *) malloc(conn->outBufSize);
+fe-connect.c:	initPQExpBuffer(&conn->errorMessage);
+fe-connect.c:	initPQExpBuffer(&conn->workBuffer);
+fe-connect.c:	if (conn->inBuffer == NULL ||
+fe-connect.c:		conn->outBuffer == NULL ||
+fe-connect.c:		conn->errorMessage.data == NULL ||
+fe-connect.c:		conn->workBuffer.data == NULL)
+fe-connect.c:	if (conn->sock >= 0)
+fe-connect.c:		closesocket(conn->sock);
+fe-connect.c:	if (conn->pghost)
+fe-connect.c:		free(conn->pghost);
+fe-connect.c:	if (conn->pghostaddr)
+fe-connect.c:		free(conn->pghostaddr);
+fe-connect.c:	if (conn->pgport)
+fe-connect.c:		free(conn->pgport);
+fe-connect.c:	if (conn->pgunixsocket)
+fe-connect.c:		free(conn->pgunixsocket);
+fe-connect.c:	if (conn->pgtty)
+fe-connect.c:		free(conn->pgtty);
+fe-connect.c:	if (conn->connect_timeout)
+fe-connect.c:		free(conn->connect_timeout);
+fe-connect.c:	if (conn->pgoptions)
+fe-connect.c:		free(conn->pgoptions);
+fe-connect.c:	if (conn->dbName)
+fe-connect.c:		free(conn->dbName);
+fe-connect.c:	if (conn->pguser)
+fe-connect.c:		free(conn->pguser);
+fe-connect.c:	if (conn->pgpass)
+fe-connect.c:		free(conn->pgpass);
+fe-connect.c:	if (conn->sslmode)
+fe-connect.c:		free(conn->sslmode);
+fe-connect.c:	if (conn->krbsrvname)
+fe-connect.c:		free(conn->krbsrvname);
+fe-connect.c:	/* Note that conn->Pfdebug is not ours to close or free */
+fe-connect.c:	if (conn->last_query)
+fe-connect.c:		free(conn->last_query);
+fe-connect.c:	pg_freeaddrinfo_all(conn->addrlist_family, conn->addrlist);
+fe-connect.c:	notify = conn->notifyHead;
+fe-connect.c:	pstatus = conn->pstatus;
+fe-connect.c:	if (conn->lobjfuncs)
+fe-connect.c:		free(conn->lobjfuncs);
+fe-connect.c:	if (conn->inBuffer)
+fe-connect.c:		free(conn->inBuffer);
+fe-connect.c:	if (conn->outBuffer)
+fe-connect.c:		free(conn->outBuffer);
+fe-connect.c:	termPQExpBuffer(&conn->errorMessage);
+fe-connect.c:	termPQExpBuffer(&conn->workBuffer);
+fe-connect.c:	if (conn->sock >= 0 && conn->status == CONNECTION_OK)
+fe-connect.c:	conn->nonblocking = FALSE;
+fe-connect.c:	if (conn->sock >= 0)
+fe-connect.c:		closesocket(conn->sock);
+fe-connect.c:	conn->sock = -1;
+fe-connect.c:	conn->status = CONNECTION_BAD;		/* Well, not really _bad_ - just
+fe-connect.c:	conn->asyncStatus = PGASYNC_IDLE;
+fe-connect.c:	pg_freeaddrinfo_all(conn->addrlist_family, conn->addrlist);
+fe-connect.c:	conn->addrlist = NULL;
+fe-connect.c:	conn->addr_cur = NULL;
+fe-connect.c:	notify = conn->notifyHead;
+fe-connect.c:	conn->notifyHead = NULL;
+fe-connect.c:	pstatus = conn->pstatus;
+fe-connect.c:	conn->pstatus = NULL;
+fe-connect.c:	if (conn->lobjfuncs)
+fe-connect.c:		free(conn->lobjfuncs);
+fe-connect.c:	conn->lobjfuncs = NULL;
+fe-connect.c:	conn->inStart = conn->inCursor = conn->inEnd = 0;
+fe-connect.c:	conn->outCount = 0;
+fe-connect.c:	if (conn->sock < 0)
+fe-connect.c:	memcpy(&cancel->raddr, &conn->raddr, sizeof(SockAddr));
+fe-connect.c:	cancel->be_pid = conn->be_pid;
+fe-connect.c:	cancel->be_key = conn->be_key;
+fe-connect.c: * On failure, the error message is saved in conn->errorMessage; this means
+fe-connect.c: * error message buffer, since we dare not try to expand conn->errorMessage!
+fe-connect.c:	if (conn->sock < 0)
+fe-connect.c:		StrNCpy(conn->errorMessage.data,
+fe-connect.c:				conn->errorMessage.maxlen);
+fe-connect.c:		conn->errorMessage.len = strlen(conn->errorMessage.data);
+fe-connect.c:	r = internal_cancel(&conn->raddr, conn->be_pid, conn->be_key,
+fe-connect.c:						conn->errorMessage.data, conn->errorMessage.maxlen);
+fe-connect.c:		conn->errorMessage.len = strlen(conn->errorMessage.data);
+fe-connect.c:	return conn->dbName;
+fe-connect.c:	return conn->pguser;
+fe-connect.c:	return conn->pgpass;
+fe-connect.c:	return conn->pghost ? conn->pghost : conn->pgunixsocket;
+fe-connect.c:	return conn->pgport;
+fe-connect.c:	return conn->pgtty;
+fe-connect.c:	return conn->pgoptions;
+fe-connect.c:	return conn->status;
+fe-connect.c:    return conn->errorCode;
+fe-connect.c:	if (!conn || conn->status != CONNECTION_OK)
+fe-connect.c:	if (conn->asyncStatus != PGASYNC_IDLE)
+fe-connect.c:	return conn->xactStatus;
+fe-connect.c:	for (pstatus = conn->pstatus; pstatus != NULL; pstatus = pstatus->next)
+fe-connect.c:	if (conn->status == CONNECTION_BAD)
+fe-connect.c:	return PG_PROTOCOL_MAJOR(conn->pversion);
+fe-connect.c:	if (conn->status == CONNECTION_BAD)
+fe-connect.c:	return conn->sversion;
+fe-connect.c:	return conn->errorMessage.data;
+fe-connect.c:	return conn->sock;
+fe-connect.c:	if (!conn || conn->status != CONNECTION_OK)
+fe-connect.c:	return conn->be_pid;
+fe-connect.c:	if (!conn || conn->status != CONNECTION_OK)
+fe-connect.c:	return conn->client_encoding;
+fe-connect.c:	if (!conn || conn->status != CONNECTION_OK)
+fe-connect.c:		if (PG_PROTOCOL_MAJOR(conn->pversion) < 3)
+fe-connect.c:	old = conn->verbosity;
+fe-connect.c:	conn->verbosity = verbosity;
+fe-connect.c:	conn->Pfdebug = debug_port;
+fe-connect.c:	if (conn->Pfdebug)
+fe-connect.c:		fflush(conn->Pfdebug);
+fe-connect.c:		conn->Pfdebug = NULL;
+fe-connect.c:	old = conn->noticeHooks.noticeRec;
+fe-connect.c:		conn->noticeHooks.noticeRec = proc;
+fe-connect.c:		conn->noticeHooks.noticeRecArg = arg;
+fe-connect.c:	old = conn->noticeHooks.noticeProc;
+fe-connect.c:		conn->noticeHooks.noticeProc = proc;
+fe-connect.c:		conn->noticeHooks.noticeProcArg = arg;
+fe-connect.c:    return conn->areq;
+fe-exec.c:		result->noticeHooks = conn->noticeHooks;
+fe-exec.c:		result->client_encoding = conn->client_encoding;
+fe-exec.c:				pqSetResultError(result, conn->errorMessage.data);
+fe-exec.c:	if (conn->result)
+fe-exec.c:		PQclear(conn->result);
+fe-exec.c:	conn->result = NULL;
+fe-exec.c:	conn->curTuple = NULL;
+fe-exec.c: * This subroutine deletes any existing async result, sets conn->result
+fe-exec.c: * contents of conn->errorMessage into that result.  It differs from a
+fe-exec.c:	if (conn->result == NULL ||
+fe-exec.c:		conn->result->resultStatus != PGRES_FATAL_ERROR ||
+fe-exec.c:		conn->result->errMsg == NULL)
+fe-exec.c:		conn->result = PQmakeEmptyPGresult(conn, PGRES_FATAL_ERROR);
+fe-exec.c:		pqCatenateResultError(conn->result, conn->errorMessage.data);
+fe-exec.c: * using whatever is in conn->errorMessage.  In any case, clear the async
+fe-exec.c:	 * conn->result is the PGresult to return.	If it is NULL (which probably
+fe-exec.c:	 * conn->errorMessage.
+fe-exec.c:	res = conn->result;
+fe-exec.c:	conn->result = NULL;		/* handing over ownership to caller */
+fe-exec.c:	conn->curTuple = NULL;		/* just in case */
+fe-exec.c:		resetPQExpBuffer(&conn->errorMessage);
+fe-exec.c:		appendPQExpBufferStr(&conn->errorMessage,
+fe-exec.c:	if (conn->Pfdebug)
+fe-exec.c:		fprintf(conn->Pfdebug, "pqSaveParameterStatus: '%s' = '%s'\n",
+fe-exec.c:	for (pstatus = conn->pstatus, prev = NULL;
+fe-exec.c:				conn->pstatus = pstatus->next;
+fe-exec.c:		pstatus->next = conn->pstatus;
+fe-exec.c:		conn->pstatus = pstatus;
+fe-exec.c:		conn->client_encoding = pg_char_to_encoding(value);
+fe-exec.c:		static_client_encoding = conn->client_encoding;
+fe-exec.c:		conn->std_strings = (strcmp(value, "on") == 0);
+fe-exec.c:		static_std_strings = conn->std_strings;
+fe-exec.c:			conn->sversion = 0; /* unknown */
+fe-exec.c:			conn->sversion = (100 * vmaj + vmin) * 100 + vrev;
+fe-exec.c: *			0 if error (conn->errorMessage is set)
+fe-exec.c:		printfPQExpBuffer(&conn->errorMessage,
+fe-exec.c:	conn->queryclass = PGQUERY_SIMPLE;
+fe-exec.c:	if (conn->last_query)
+fe-exec.c:		free(conn->last_query);
+fe-exec.c:	conn->last_query = strdup(query);
+fe-exec.c:	conn->asyncStatus = PGASYNC_BUSY;
+fe-exec.c:		printfPQExpBuffer(&conn->errorMessage,
+fe-exec.c: *			0 if error (conn->errorMessage is set)
+fe-exec.c:		printfPQExpBuffer(&conn->errorMessage,
+fe-exec.c:		printfPQExpBuffer(&conn->errorMessage,
+fe-exec.c:	if (PG_PROTOCOL_MAJOR(conn->pversion) < 3)
+fe-exec.c:		printfPQExpBuffer(&conn->errorMessage,
+fe-exec.c:	conn->queryclass = PGQUERY_PREPARE;
+fe-exec.c:	if (conn->last_query)
+fe-exec.c:		free(conn->last_query);
+fe-exec.c:	conn->last_query = strdup(query);
+fe-exec.c:	conn->asyncStatus = PGASYNC_BUSY;
+fe-exec.c:		printfPQExpBuffer(&conn->errorMessage,
+fe-exec.c:	resetPQExpBuffer(&conn->errorMessage);
+fe-exec.c:	if (conn->status != CONNECTION_OK)
+fe-exec.c:		printfPQExpBuffer(&conn->errorMessage,
+fe-exec.c:	if (conn->asyncStatus != PGASYNC_IDLE)
+fe-exec.c:		printfPQExpBuffer(&conn->errorMessage,
+fe-exec.c:	conn->result = NULL;
+fe-exec.c:	conn->curTuple = NULL;
+fe-exec.c:	if (PG_PROTOCOL_MAJOR(conn->pversion) < 3)
+fe-exec.c:		printfPQExpBuffer(&conn->errorMessage,
+fe-exec.c:					printfPQExpBuffer(&conn->errorMessage,
+fe-exec.c:	conn->queryclass = PGQUERY_EXTENDED;
+fe-exec.c:	if (conn->last_query)
+fe-exec.c:		free(conn->last_query);
+fe-exec.c:		conn->last_query = strdup(command);
+fe-exec.c:		conn->last_query = NULL;
+fe-exec.c:	conn->asyncStatus = PGASYNC_BUSY;
+fe-exec.c:	if (PG_PROTOCOL_MAJOR(conn->pversion) >= 3)
+fe-exec.c:	return conn->asyncStatus == PGASYNC_BUSY;
+fe-exec.c:	while (conn->asyncStatus == PGASYNC_BUSY)
+fe-exec.c:			 * conn->errorMessage has been set by pqWait or pqReadData. We
+fe-exec.c:			conn->asyncStatus = PGASYNC_IDLE;
+fe-exec.c:	switch (conn->asyncStatus)
+fe-exec.c:			conn->asyncStatus = PGASYNC_BUSY;
+fe-exec.c:			if (conn->result && conn->result->resultStatus == PGRES_COPY_IN)
+fe-exec.c:			if (conn->result && conn->result->resultStatus == PGRES_COPY_OUT)
+fe-exec.c:			printfPQExpBuffer(&conn->errorMessage,
+fe-exec.c:							  (int) conn->asyncStatus);
+fe-exec.c: * If the query was not even sent, return NULL; conn->errorMessage is set to
+fe-exec.c: * If the query was not even sent, return NULL; conn->errorMessage is set to
+fe-exec.c:			if (PG_PROTOCOL_MAJOR(conn->pversion) >= 3)
+fe-exec.c:				printfPQExpBuffer(&conn->errorMessage,
+fe-exec.c:			if (PG_PROTOCOL_MAJOR(conn->pversion) >= 3)
+fe-exec.c:				conn->asyncStatus = PGASYNC_BUSY;
+fe-exec.c:				printfPQExpBuffer(&conn->errorMessage,
+fe-exec.c:		if (conn->status == CONNECTION_BAD)
+fe-exec.c:				resetPQExpBuffer(&conn->errorMessage);
+fe-exec.c:				appendPQExpBufferStr(&conn->errorMessage, result->errMsg);
+fe-exec.c:			conn->status == CONNECTION_BAD)
+fe-exec.c: * If the query was not even sent, return NULL; conn->errorMessage is set to
+fe-exec.c: *			0 if error (conn->errorMessage is set)
+fe-exec.c: *			0 if error (conn->errorMessage is set)
+fe-exec.c:	if (PG_PROTOCOL_MAJOR(conn->pversion) < 3)
+fe-exec.c:		printfPQExpBuffer(&conn->errorMessage,
+fe-exec.c:	conn->queryclass = PGQUERY_DESCRIBE;
+fe-exec.c:	if (conn->last_query)
+fe-exec.c:		free(conn->last_query);
+fe-exec.c:		conn->last_query = NULL;
+fe-exec.c:	conn->asyncStatus = PGASYNC_BUSY;
+fe-exec.c:	event = conn->notifyHead;
+fe-exec.c:		conn->notifyHead = event->next;
+fe-exec.c:		if (!conn->notifyHead)
+fe-exec.c:			conn->notifyTail = NULL;
+fe-exec.c:	if (conn->asyncStatus != PGASYNC_COPY_IN)
+fe-exec.c:		printfPQExpBuffer(&conn->errorMessage,
+fe-exec.c:		if ((conn->outBufSize - conn->outCount - 5) < nbytes)
+fe-exec.c:			if (pqCheckOutBufferSpace(conn->outCount + 5 + nbytes, conn))
+fe-exec.c:		if (PG_PROTOCOL_MAJOR(conn->pversion) >= 3)
+fe-exec.c:	if (conn->asyncStatus != PGASYNC_COPY_IN)
+fe-exec.c:		printfPQExpBuffer(&conn->errorMessage,
+fe-exec.c:	if (PG_PROTOCOL_MAJOR(conn->pversion) >= 3)
+fe-exec.c:		if (conn->queryclass != PGQUERY_SIMPLE)
+fe-exec.c:			printfPQExpBuffer(&conn->errorMessage,
+fe-exec.c:	conn->asyncStatus = PGASYNC_BUSY;
+fe-exec.c:	resetPQExpBuffer(&conn->errorMessage);
+fe-exec.c:	if (conn->asyncStatus != PGASYNC_COPY_OUT)
+fe-exec.c:		printfPQExpBuffer(&conn->errorMessage,
+fe-exec.c:	if (PG_PROTOCOL_MAJOR(conn->pversion) >= 3)
+fe-exec.c:	if (PG_PROTOCOL_MAJOR(conn->pversion) >= 3)
+fe-exec.c:	if (PG_PROTOCOL_MAJOR(conn->pversion) >= 3)
+fe-exec.c:	if (PG_PROTOCOL_MAJOR(conn->pversion) >= 3)
+fe-exec.c: *		NULL on communications failure.  conn->errorMessage will be set.
+fe-exec.c:	resetPQExpBuffer(&conn->errorMessage);
+fe-exec.c:	if (conn->sock < 0 || conn->asyncStatus != PGASYNC_IDLE ||
+fe-exec.c:		conn->result != NULL)
+fe-exec.c:		printfPQExpBuffer(&conn->errorMessage,
+fe-exec.c:	if (PG_PROTOCOL_MAJOR(conn->pversion) >= 3)
+fe-exec.c:	if (!conn || conn->status == CONNECTION_BAD)
+fe-exec.c:	if (barg == conn->nonblocking)
+fe-exec.c:	conn->nonblocking = barg;
+fe-exec.c:				printfPQExpBuffer(&conn->errorMessage,
+fe-exec.c:								  conn->client_encoding,
+fe-exec.c:								  conn->std_strings);
+fe-exec.c:			printfPQExpBuffer(&conn->errorMessage,
+fe-exec.c:								 conn->std_strings);
+fe-lobj.c:	if (conn->lobjfuncs == NULL)
+fe-lobj.c:	res = PQfn(conn, conn->lobjfuncs->fn_lo_open, &fd, &result_len, 1, argv, 2);
+fe-lobj.c:	if (conn->lobjfuncs == NULL)
+fe-lobj.c:	res = PQfn(conn, conn->lobjfuncs->fn_lo_close,
+fe-lobj.c:	if (conn->lobjfuncs == NULL)
+fe-lobj.c:	res = PQfn(conn, conn->lobjfuncs->fn_lo_read,
+fe-lobj.c:	if (conn->lobjfuncs == NULL)
+fe-lobj.c:	res = PQfn(conn, conn->lobjfuncs->fn_lo_write,
+fe-lobj.c:	if (conn->lobjfuncs == NULL)
+fe-lobj.c:	res = PQfn(conn, conn->lobjfuncs->fn_lo_lseek,
+fe-lobj.c:	if (conn->lobjfuncs == NULL)
+fe-lobj.c:	res = PQfn(conn, conn->lobjfuncs->fn_lo_creat,
+fe-lobj.c:	if (conn->lobjfuncs == NULL)
+fe-lobj.c:	if (conn->lobjfuncs->fn_lo_create == 0)
+fe-lobj.c:		printfPQExpBuffer(&conn->errorMessage,
+fe-lobj.c:	res = PQfn(conn, conn->lobjfuncs->fn_lo_create,
+fe-lobj.c:	if (conn->lobjfuncs == NULL)
+fe-lobj.c:	res = PQfn(conn, conn->lobjfuncs->fn_lo_tell,
+fe-lobj.c:	if (conn->lobjfuncs == NULL)
+fe-lobj.c:	res = PQfn(conn, conn->lobjfuncs->fn_lo_unlink,
+fe-lobj.c:		printfPQExpBuffer(&conn->errorMessage,
+fe-lobj.c:		printfPQExpBuffer(&conn->errorMessage,
+fe-lobj.c:		printfPQExpBuffer(&conn->errorMessage,
+fe-lobj.c:			printfPQExpBuffer(&conn->errorMessage,
+fe-lobj.c:		printfPQExpBuffer(&conn->errorMessage,
+fe-lobj.c:		printfPQExpBuffer(&conn->errorMessage,
+fe-lobj.c:	if (conn->sversion >= 70300)
+fe-lobj.c:		printfPQExpBuffer(&conn->errorMessage,
+fe-lobj.c:		printfPQExpBuffer(&conn->errorMessage,
+fe-lobj.c:		printfPQExpBuffer(&conn->errorMessage,
+fe-lobj.c:		printfPQExpBuffer(&conn->errorMessage,
+fe-lobj.c:		printfPQExpBuffer(&conn->errorMessage,
+fe-lobj.c:		printfPQExpBuffer(&conn->errorMessage,
+fe-lobj.c:		printfPQExpBuffer(&conn->errorMessage,
+fe-lobj.c:		printfPQExpBuffer(&conn->errorMessage,
+fe-lobj.c:		printfPQExpBuffer(&conn->errorMessage,
+fe-lobj.c:	conn->lobjfuncs = lobjfuncs;
+fe-misc.c:	if (conn->inCursor >= conn->inEnd)
+fe-misc.c:	*result = conn->inBuffer[conn->inCursor++];
+fe-misc.c:	if (conn->Pfdebug)
+fe-misc.c:		fprintf(conn->Pfdebug, "From backend> %c\n", *result);
+fe-misc.c:	if (conn->Pfdebug)
+fe-misc.c:		fprintf(conn->Pfdebug, "To backend> %c\n", c);
+fe-misc.c:	char	   *inBuffer = conn->inBuffer;
+fe-misc.c:	int			inCursor = conn->inCursor;
+fe-misc.c:	int			inEnd = conn->inEnd;
+fe-misc.c:	slen = inCursor - conn->inCursor;
+fe-misc.c:	appendBinaryPQExpBuffer(buf, inBuffer + conn->inCursor, slen);
+fe-misc.c:	conn->inCursor = ++inCursor;
+fe-misc.c:	if (conn->Pfdebug)
+fe-misc.c:		fprintf(conn->Pfdebug, "From backend> \"%s\"\n",
+fe-misc.c:	if (conn->Pfdebug)
+fe-misc.c:		fprintf(conn->Pfdebug, "To backend> \"%s\"\n", s);
+fe-misc.c:	if (len < 0 || len > (size_t) (conn->inEnd - conn->inCursor))
+fe-misc.c:	memcpy(s, conn->inBuffer + conn->inCursor, len);
+fe-misc.c:	conn->inCursor += len;
+fe-misc.c:	if (conn->Pfdebug)
+fe-misc.c:		fprintf(conn->Pfdebug, "From backend (%lu)> %.*s\n",
+fe-misc.c:	if (conn->Pfdebug)
+fe-misc.c:		fprintf(conn->Pfdebug, "To backend> %.*s\n", (int) len, s);
+fe-misc.c:			if (conn->inCursor + 2 > conn->inEnd)
+fe-misc.c:			memcpy(&tmp2, conn->inBuffer + conn->inCursor, 2);
+fe-misc.c:			conn->inCursor += 2;
+fe-misc.c:			if (conn->inCursor + 4 > conn->inEnd)
+fe-misc.c:			memcpy(&tmp4, conn->inBuffer + conn->inCursor, 4);
+fe-misc.c:			conn->inCursor += 4;
+fe-misc.c:			pqInternalNotice(&conn->noticeHooks,
+fe-misc.c:	if (conn->Pfdebug)
+fe-misc.c:		fprintf(conn->Pfdebug, "From backend (#%lu)> %d\n", (unsigned long) bytes, *result);
+fe-misc.c:			pqInternalNotice(&conn->noticeHooks,
+fe-misc.c:	if (conn->Pfdebug)
+fe-misc.c:		fprintf(conn->Pfdebug, "To backend (%lu#)> %d\n", (unsigned long) bytes, value);
+fe-misc.c:	int			newsize = conn->outBufSize;
+fe-misc.c:		newbuf = realloc(conn->outBuffer, newsize);
+fe-misc.c:			conn->outBuffer = newbuf;
+fe-misc.c:			conn->outBufSize = newsize;
+fe-misc.c:	newsize = conn->outBufSize;
+fe-misc.c:		newbuf = realloc(conn->outBuffer, newsize);
+fe-misc.c:			conn->outBuffer = newbuf;
+fe-misc.c:			conn->outBufSize = newsize;
+fe-misc.c:	printfPQExpBuffer(&conn->errorMessage,
+fe-misc.c:	int			newsize = conn->inBufSize;
+fe-misc.c:		newbuf = realloc(conn->inBuffer, newsize);
+fe-misc.c:			conn->inBuffer = newbuf;
+fe-misc.c:			conn->inBufSize = newsize;
+fe-misc.c:	newsize = conn->inBufSize;
+fe-misc.c:		newbuf = realloc(conn->inBuffer, newsize);
+fe-misc.c:			conn->inBuffer = newbuf;
+fe-misc.c:			conn->inBufSize = newsize;
+fe-misc.c:	printfPQExpBuffer(&conn->errorMessage,
+fe-misc.c: * The idea here is that we construct the message in conn->outBuffer,
+fe-misc.c: * The state variable conn->outMsgStart points to the incomplete message's
+fe-misc.c: * conn->outMsgEnd is the end of the data collected so far.
+fe-misc.c:		endPos = conn->outCount + 1;
+fe-misc.c:		endPos = conn->outCount;
+fe-misc.c:	if (force_len || PG_PROTOCOL_MAJOR(conn->pversion) >= 3)
+fe-misc.c:		conn->outBuffer[conn->outCount] = msg_type;
+fe-misc.c:	conn->outMsgStart = lenPos;
+fe-misc.c:	conn->outMsgEnd = endPos;
+fe-misc.c:	if (conn->Pfdebug)
+fe-misc.c:		fprintf(conn->Pfdebug, "To backend> Msg %c\n",
+fe-misc.c:	if (pqCheckOutBufferSpace(conn->outMsgEnd + len, conn))
+fe-misc.c:	memcpy(conn->outBuffer + conn->outMsgEnd, buf, len);
+fe-misc.c:	conn->outMsgEnd += len;
+fe-misc.c:	if (conn->Pfdebug)
+fe-misc.c:		fprintf(conn->Pfdebug, "To backend> Msg complete, length %u\n",
+fe-misc.c:				conn->outMsgEnd - conn->outCount);
+fe-misc.c:	if (conn->outMsgStart >= 0)
+fe-misc.c:		uint32		msgLen = conn->outMsgEnd - conn->outMsgStart;
+fe-misc.c:		memcpy(conn->outBuffer + conn->outMsgStart, &msgLen, 4);
+fe-misc.c:	conn->outCount = conn->outMsgEnd;
+fe-misc.c:	if (conn->outCount >= 8192)
+fe-misc.c:		int			toSend = conn->outCount - (conn->outCount % 8192);
+fe-misc.c: *		conn->errorMessage set
+fe-misc.c: * NOTE: callers must not assume that pointers or indexes into conn->inBuffer
+fe-misc.c:	if (conn->sock < 0)
+fe-misc.c:		printfPQExpBuffer(&conn->errorMessage,
+fe-misc.c:	if (conn->inStart < conn->inEnd)
+fe-misc.c:		if (conn->inStart > 0)
+fe-misc.c:			memmove(conn->inBuffer, conn->inBuffer + conn->inStart,
+fe-misc.c:					conn->inEnd - conn->inStart);
+fe-misc.c:			conn->inEnd -= conn->inStart;
+fe-misc.c:			conn->inCursor -= conn->inStart;
+fe-misc.c:			conn->inStart = 0;
+fe-misc.c:		conn->inStart = conn->inCursor = conn->inEnd = 0;
+fe-misc.c:	if (conn->inBufSize - conn->inEnd < 8192)
+fe-misc.c:		if (pqCheckInBufferSpace(conn->inEnd + 8192, conn))
+fe-misc.c:			if (conn->inBufSize - conn->inEnd < 100)
+fe-misc.c:	nread = pqsecure_read(conn, conn->inBuffer + conn->inEnd,
+fe-misc.c:						  conn->inBufSize - conn->inEnd);
+fe-misc.c:		printfPQExpBuffer(&conn->errorMessage,
+fe-misc.c:		conn->inEnd += nread;
+fe-misc.c:		 * Since we left-justified the data above, conn->inEnd gives the
+fe-misc.c:		if (conn->inEnd > 32768 &&
+fe-misc.c:			(conn->inBufSize - conn->inEnd) >= 8192)
+fe-misc.c:	if (conn->ssl)
+fe-misc.c:	nread = pqsecure_read(conn, conn->inBuffer + conn->inEnd,
+fe-misc.c:						  conn->inBufSize - conn->inEnd);
+fe-misc.c:		printfPQExpBuffer(&conn->errorMessage,
+fe-misc.c:		conn->inEnd += nread;
+fe-misc.c:	printfPQExpBuffer(&conn->errorMessage,
+fe-misc.c:	conn->status = CONNECTION_BAD;		/* No more connection to backend */
+fe-misc.c:	closesocket(conn->sock);
+fe-misc.c:	conn->sock = -1;
+fe-misc.c:	char	   *ptr = conn->outBuffer;
+fe-misc.c:	int			remaining = conn->outCount;
+fe-misc.c:	if (conn->sock < 0)
+fe-misc.c:		printfPQExpBuffer(&conn->errorMessage,
+fe-misc.c:					printfPQExpBuffer(&conn->errorMessage,
+fe-misc.c:					conn->outCount = 0;
+fe-misc.c:					printfPQExpBuffer(&conn->errorMessage,
+fe-misc.c:					conn->outCount = 0;
+fe-misc.c:		memmove(conn->outBuffer, ptr, remaining);
+fe-misc.c:	conn->outCount = remaining;
+fe-misc.c:	if (conn->Pfdebug)
+fe-misc.c:		fflush(conn->Pfdebug);
+fe-misc.c:	if (conn->outCount > 0)
+fe-misc.c:		return pqSendSome(conn, conn->outCount);
+fe-misc.c:		printfPQExpBuffer(&conn->errorMessage,
+fe-misc.c:	if (conn->sock < 0)
+fe-misc.c:		printfPQExpBuffer(&conn->errorMessage,
+fe-misc.c:	if (forRead && conn->ssl && SSL_pending(conn->ssl) > 0)
+fe-misc.c:		result = pqSocketPoll(conn->sock, forRead, forWrite, end_time);
+fe-misc.c:		printfPQExpBuffer(&conn->errorMessage,
+fe-protocol2.c:	if (conn == NULL || conn->status == CONNECTION_BAD)
+fe-protocol2.c:	switch (conn->setenv_state)
+fe-protocol2.c:			printfPQExpBuffer(&conn->errorMessage,
+fe-protocol2.c:							  conn->setenv_state);
+fe-protocol2.c:		switch (conn->setenv_state)
+fe-protocol2.c:					if (conn->next_eo->envName)
+fe-protocol2.c:						if ((val = getenv(conn->next_eo->envName)))
+fe-protocol2.c:										conn->next_eo->pgName);
+fe-protocol2.c:										conn->next_eo->pgName, val);
+fe-protocol2.c:									conn->next_eo->envName, setQuery);
+fe-protocol2.c:							conn->setenv_state = SETENV_STATE_OPTION_WAIT;
+fe-protocol2.c:							conn->next_eo++;
+fe-protocol2.c:						conn->setenv_state = SETENV_STATE_QUERY1_SEND;
+fe-protocol2.c:						conn->next_eo++;
+fe-protocol2.c:						conn->setenv_state = SETENV_STATE_OPTION_SEND;
+fe-protocol2.c:					conn->setenv_state = SETENV_STATE_QUERY1_WAIT;
+fe-protocol2.c:						conn->setenv_state = SETENV_STATE_QUERY2_SEND;
+fe-protocol2.c:					if (conn->sversion >= 70300 &&
+fe-protocol2.c:						conn->sversion < 70400)
+fe-protocol2.c:					conn->setenv_state = SETENV_STATE_QUERY2_WAIT;
+fe-protocol2.c:						conn->setenv_state = SETENV_STATE_IDLE;
+fe-protocol2.c:				printfPQExpBuffer(&conn->errorMessage,
+fe-protocol2.c:								  conn->setenv_state);
+fe-protocol2.c:	conn->setenv_state = SETENV_STATE_IDLE;
+fe-protocol2.c:		if (conn->asyncStatus == PGASYNC_COPY_OUT)
+fe-protocol2.c:		conn->inCursor = conn->inStart;
+fe-protocol2.c:		else if (conn->asyncStatus != PGASYNC_BUSY)
+fe-protocol2.c:			if (conn->asyncStatus != PGASYNC_IDLE)
+fe-protocol2.c:				pqInternalNotice(&conn->noticeHooks,
+fe-protocol2.c:				conn->inStart = conn->inEnd;
+fe-protocol2.c:					if (pqGets(&conn->workBuffer, conn))
+fe-protocol2.c:					if (conn->result == NULL)
+fe-protocol2.c:						conn->result = PQmakeEmptyPGresult(conn,
+fe-protocol2.c:						if (!conn->result)
+fe-protocol2.c:					strncpy(conn->result->cmdStatus, conn->workBuffer.data,
+fe-protocol2.c:					checkXactStatus(conn, conn->workBuffer.data);
+fe-protocol2.c:					conn->asyncStatus = PGASYNC_READY;
+fe-protocol2.c:					conn->asyncStatus = PGASYNC_READY;
+fe-protocol2.c:					conn->asyncStatus = PGASYNC_IDLE;
+fe-protocol2.c:						pqInternalNotice(&conn->noticeHooks,
+fe-protocol2.c:					if (conn->result == NULL)
+fe-protocol2.c:						conn->result = PQmakeEmptyPGresult(conn,
+fe-protocol2.c:					conn->asyncStatus = PGASYNC_READY;
+fe-protocol2.c:					if (pqGetInt(&(conn->be_pid), 4, conn))
+fe-protocol2.c:					if (pqGetInt(&(conn->be_key), 4, conn))
+fe-protocol2.c:					if (pqGets(&conn->workBuffer, conn))
+fe-protocol2.c:					if (conn->result == NULL)
+fe-protocol2.c:						conn->asyncStatus = PGASYNC_READY;
+fe-protocol2.c:					if (conn->result != NULL)
+fe-protocol2.c:						pqInternalNotice(&conn->noticeHooks,
+fe-protocol2.c:						conn->inStart = conn->inEnd;
+fe-protocol2.c:					if (conn->result != NULL)
+fe-protocol2.c:						pqInternalNotice(&conn->noticeHooks,
+fe-protocol2.c:						conn->inStart = conn->inEnd;
+fe-protocol2.c:					conn->asyncStatus = PGASYNC_COPY_IN;
+fe-protocol2.c:					conn->asyncStatus = PGASYNC_COPY_OUT;
+fe-protocol2.c:					printfPQExpBuffer(&conn->errorMessage,
+fe-protocol2.c:					conn->inStart = conn->inEnd;
+fe-protocol2.c:					conn->asyncStatus = PGASYNC_READY;
+fe-protocol2.c:		conn->inStart = conn->inCursor;
+fe-protocol2.c:		if (pqGets(&conn->workBuffer, conn) ||
+fe-protocol2.c:												  conn->workBuffer.data);
+fe-protocol2.c:	conn->result = result;
+fe-protocol2.c: * tuple in conn->curTuple, and avoid reallocating already-allocated storage.
+fe-protocol2.c:	PGresult   *result = conn->result;
+fe-protocol2.c:	if (conn->curTuple == NULL)
+fe-protocol2.c:		conn->curTuple = (PGresAttValue *)
+fe-protocol2.c:		if (conn->curTuple == NULL)
+fe-protocol2.c:		MemSet(conn->curTuple, 0, nfields * sizeof(PGresAttValue));
+fe-protocol2.c:	tup = conn->curTuple;
+fe-protocol2.c:	conn->curTuple = NULL;
+fe-protocol2.c:	printfPQExpBuffer(&conn->errorMessage,
+fe-protocol2.c:	conn->result = PQmakeEmptyPGresult(conn, PGRES_FATAL_ERROR);
+fe-protocol2.c:	conn->asyncStatus = PGASYNC_READY;
+fe-protocol2.c:	conn->inStart = conn->inEnd;
+fe-protocol2.c:	 * PQExpBuffer rather than using conn->workBuffer.	workBuffer is intended
+fe-protocol2.c:	 * conn->errorMessage.
+fe-protocol2.c:		conn->result = res;
+fe-protocol2.c:		resetPQExpBuffer(&conn->errorMessage);
+fe-protocol2.c:		appendPQExpBufferStr(&conn->errorMessage, res->errMsg);
+fe-protocol2.c:		if (conn->xactStatus == PQTRANS_INTRANS)
+fe-protocol2.c:			conn->xactStatus = PQTRANS_INERROR;
+fe-protocol2.c:		conn->xactStatus = PQTRANS_INTRANS;
+fe-protocol2.c:		conn->xactStatus = PQTRANS_IDLE;
+fe-protocol2.c:		conn->xactStatus = PQTRANS_IDLE;
+fe-protocol2.c:		conn->xactStatus = PQTRANS_INTRANS;
+fe-protocol2.c:		conn->xactStatus = PQTRANS_INERROR;
+fe-protocol2.c:	if (pqGets(&conn->workBuffer, conn))
+fe-protocol2.c:	nmlen = strlen(conn->workBuffer.data);
+fe-protocol2.c:		strcpy(newNotify->relname, conn->workBuffer.data);
+fe-protocol2.c:		if (conn->notifyTail)
+fe-protocol2.c:			conn->notifyTail->next = newNotify;
+fe-protocol2.c:			conn->notifyHead = newNotify;
+fe-protocol2.c:		conn->notifyTail = newNotify;
+fe-protocol2.c:		conn->inCursor = conn->inStart;
+fe-protocol2.c:		while (conn->inCursor < conn->inEnd)
+fe-protocol2.c:			char		c = conn->inBuffer[conn->inCursor++];
+fe-protocol2.c:		msgLength = conn->inCursor - conn->inStart;
+fe-protocol2.c:			strncmp(&conn->inBuffer[conn->inStart], "\\.\n", 3) == 0)
+fe-protocol2.c:			conn->inStart = conn->inCursor;
+fe-protocol2.c:			conn->asyncStatus = PGASYNC_BUSY;
+fe-protocol2.c:			printfPQExpBuffer(&conn->errorMessage,
+fe-protocol2.c:		memcpy(*buffer, &conn->inBuffer[conn->inStart], msgLength);
+fe-protocol2.c:		conn->inStart = conn->inCursor;
+fe-protocol2.c:	if (conn->sock < 0)
+fe-protocol2.c:	 * conn->inCursor; there is no need to back up.
+fe-protocol2.c:		if (conn->inStart < conn->inEnd)
+fe-protocol2.c:			char		c = conn->inBuffer[conn->inStart++];
+fe-protocol2.c:	if (conn->asyncStatus != PGASYNC_COPY_OUT)
+fe-protocol2.c:	conn->inCursor = conn->inStart;
+fe-protocol2.c:	while (avail > 0 && conn->inCursor < conn->inEnd)
+fe-protocol2.c:		char		c = conn->inBuffer[conn->inCursor++];
+fe-protocol2.c:			conn->inStart = conn->inCursor;
+fe-protocol2.c:		conn->inStart = conn->inCursor - 3;
+fe-protocol2.c:	if (conn->asyncStatus != PGASYNC_COPY_IN &&
+fe-protocol2.c:		conn->asyncStatus != PGASYNC_COPY_OUT)
+fe-protocol2.c:		printfPQExpBuffer(&conn->errorMessage,
+fe-protocol2.c:	conn->asyncStatus = PGASYNC_BUSY;
+fe-protocol2.c:	resetPQExpBuffer(&conn->errorMessage);
+fe-protocol2.c:	if (conn->errorMessage.len > 0)
+fe-protocol2.c:		char		svLast = conn->errorMessage.data[conn->errorMessage.len - 1];
+fe-protocol2.c:			conn->errorMessage.data[conn->errorMessage.len - 1] = '\0';
+fe-protocol2.c:		pqInternalNotice(&conn->noticeHooks, "%s", conn->errorMessage.data);
+fe-protocol2.c:		conn->errorMessage.data[conn->errorMessage.len - 1] = svLast;
+fe-protocol2.c:	pqInternalNotice(&conn->noticeHooks,
+fe-protocol2.c:		conn->inCursor = conn->inStart;
+fe-protocol2.c:					printfPQExpBuffer(&conn->errorMessage,
+fe-protocol2.c:					conn->inStart = conn->inCursor;
+fe-protocol2.c:				conn->inStart = conn->inCursor;
+fe-protocol2.c:				if (conn->result)
+fe-protocol2.c:				printfPQExpBuffer(&conn->errorMessage,
+fe-protocol2.c:				conn->inStart = conn->inCursor;
+fe-protocol2.c:		conn->inStart = conn->inCursor;
+fe-protocol2.c:	 * conn->errorMessage has been set by pqWait or pqReadData. We want to
+fe-protocol2.c:	startpacket->protoVersion = htonl(conn->pversion);
+fe-protocol2.c:	strncpy(startpacket->user, conn->pguser, SM_USER);
+fe-protocol2.c:	strncpy(startpacket->database, conn->dbName, SM_DATABASE);
+fe-protocol2.c:	strncpy(startpacket->tty, conn->pgtty, SM_TTY);
+fe-protocol2.c:	if (conn->pgoptions)
+fe-protocol2.c:		strncpy(startpacket->options, conn->pgoptions, SM_OPTIONS);
+fe-protocol3.c:		conn->inCursor = conn->inStart;
+fe-protocol3.c:		avail = conn->inEnd - conn->inCursor;
+fe-protocol3.c:			if (pqCheckInBufferSpace(conn->inCursor + msgLength, conn))
+fe-protocol3.c:		else if (conn->asyncStatus != PGASYNC_BUSY)
+fe-protocol3.c:			if (conn->asyncStatus != PGASYNC_IDLE)
+fe-protocol3.c:				pqInternalNotice(&conn->noticeHooks,
+fe-protocol3.c:				conn->inCursor += msgLength;
+fe-protocol3.c:					if (pqGets(&conn->workBuffer, conn))
+fe-protocol3.c:					if (conn->result == NULL)
+fe-protocol3.c:						conn->result = PQmakeEmptyPGresult(conn,
+fe-protocol3.c:						if (!conn->result)
+fe-protocol3.c:					strncpy(conn->result->cmdStatus, conn->workBuffer.data,
+fe-protocol3.c:					conn->asyncStatus = PGASYNC_READY;
+fe-protocol3.c:					conn->asyncStatus = PGASYNC_READY;
+fe-protocol3.c:					conn->asyncStatus = PGASYNC_IDLE;
+fe-protocol3.c:					if (conn->result == NULL)
+fe-protocol3.c:						conn->result = PQmakeEmptyPGresult(conn,
+fe-protocol3.c:						if (!conn->result)
+fe-protocol3.c:					conn->asyncStatus = PGASYNC_READY;
+fe-protocol3.c:					if (conn->queryclass == PGQUERY_PREPARE)
+fe-protocol3.c:						if (conn->result == NULL)
+fe-protocol3.c:							conn->result = PQmakeEmptyPGresult(conn,
+fe-protocol3.c:							if (!conn->result)
+fe-protocol3.c:						conn->asyncStatus = PGASYNC_READY;
+fe-protocol3.c:					if (pqGetInt(&(conn->be_pid), 4, conn))
+fe-protocol3.c:					if (pqGetInt(&(conn->be_key), 4, conn))
+fe-protocol3.c:					if (conn->result == NULL ||
+fe-protocol3.c:						conn->queryclass == PGQUERY_DESCRIBE)
+fe-protocol3.c:						if (conn->queryclass == PGQUERY_DESCRIBE)
+fe-protocol3.c:							conn->asyncStatus = PGASYNC_READY;
+fe-protocol3.c:						conn->asyncStatus = PGASYNC_READY;
+fe-protocol3.c:					if (conn->result == NULL)
+fe-protocol3.c:						conn->result = PQmakeEmptyPGresult(conn,
+fe-protocol3.c:					if (conn->queryclass == PGQUERY_DESCRIBE)
+fe-protocol3.c:						conn->asyncStatus = PGASYNC_READY;
+fe-protocol3.c:					if (conn->result != NULL &&
+fe-protocol3.c:						conn->result->resultStatus == PGRES_TUPLES_OK)
+fe-protocol3.c:					else if (conn->result != NULL &&
+fe-protocol3.c:							 conn->result->resultStatus == PGRES_FATAL_ERROR)
+fe-protocol3.c:						conn->inCursor += msgLength;
+fe-protocol3.c:						printfPQExpBuffer(&conn->errorMessage,
+fe-protocol3.c:						conn->inCursor += msgLength;
+fe-protocol3.c:					conn->asyncStatus = PGASYNC_COPY_IN;
+fe-protocol3.c:					conn->asyncStatus = PGASYNC_COPY_OUT;
+fe-protocol3.c:					conn->copy_already_done = 0;
+fe-protocol3.c:					conn->inCursor += msgLength;
+fe-protocol3.c:					printfPQExpBuffer(&conn->errorMessage,
+fe-protocol3.c:					conn->asyncStatus = PGASYNC_READY;
+fe-protocol3.c:					conn->inCursor += msgLength;
+fe-protocol3.c:		if (conn->inCursor == conn->inStart + 5 + msgLength)
+fe-protocol3.c:			conn->inStart = conn->inCursor;
+fe-protocol3.c:			printfPQExpBuffer(&conn->errorMessage,
+fe-protocol3.c:			conn->asyncStatus = PGASYNC_READY;
+fe-protocol3.c:			conn->inStart += 5 + msgLength;
+fe-protocol3.c:	printfPQExpBuffer(&conn->errorMessage,
+fe-protocol3.c:	conn->asyncStatus = PGASYNC_READY;	/* drop out of GetResult wait loop */
+fe-protocol3.c:	closesocket(conn->sock);
+fe-protocol3.c:	conn->sock = -1;
+fe-protocol3.c:	conn->status = CONNECTION_BAD;		/* No more connection to backend */
+fe-protocol3.c:	if (conn->queryclass == PGQUERY_DESCRIBE)
+fe-protocol3.c:		if (conn->result)
+fe-protocol3.c:			result = conn->result;
+fe-protocol3.c:		if (pqGets(&conn->workBuffer, conn) ||
+fe-protocol3.c:												  conn->workBuffer.data);
+fe-protocol3.c:	conn->result = result;
+fe-protocol3.c:	if (result != conn->result)
+fe-protocol3.c:	conn->result = result;
+fe-protocol3.c: * tuple in conn->curTuple, and avoid reallocating already-allocated storage.
+fe-protocol3.c:	PGresult   *result = conn->result;
+fe-protocol3.c:	if (conn->curTuple == NULL)
+fe-protocol3.c:		conn->curTuple = (PGresAttValue *)
+fe-protocol3.c:		if (conn->curTuple == NULL)
+fe-protocol3.c:		MemSet(conn->curTuple, 0, nfields * sizeof(PGresAttValue));
+fe-protocol3.c:	tup = conn->curTuple;
+fe-protocol3.c:		printfPQExpBuffer(&conn->errorMessage,
+fe-protocol3.c:		conn->inCursor = conn->inStart + 5 + msgLength;
+fe-protocol3.c:	conn->curTuple = NULL;
+fe-protocol3.c:	printfPQExpBuffer(&conn->errorMessage,
+fe-protocol3.c:	conn->inCursor = conn->inStart + 5 + msgLength;
+fe-protocol3.c:	 * PQExpBuffer rather than using conn->workBuffer.	workBuffer is intended
+fe-protocol3.c:	 * conn->errorMessage either, since this might be only a notice.
+fe-protocol3.c:	 * copy conn->errorMessage.
+fe-protocol3.c:	if (conn->verbosity == PQERRORS_VERBOSE)
+fe-protocol3.c:		if (conn->verbosity != PQERRORS_TERSE && conn->last_query != NULL)
+fe-protocol3.c:			querytext = conn->last_query;
+fe-protocol3.c:			if (conn->verbosity != PQERRORS_TERSE && querytext != NULL)
+fe-protocol3.c:	if (conn->verbosity != PQERRORS_TERSE)
+fe-protocol3.c:								conn->client_encoding);
+fe-protocol3.c:	if (conn->verbosity == PQERRORS_VERBOSE)
+fe-protocol3.c:		conn->result = res;
+fe-protocol3.c:		resetPQExpBuffer(&conn->errorMessage);
+fe-protocol3.c:		appendPQExpBufferStr(&conn->errorMessage, workBuf.data);
+fe-protocol3.c:	if (pqGets(&conn->workBuffer, conn))
+fe-protocol3.c:	pqSaveParameterStatus(conn, conn->workBuffer.data, valueBuf.data);
+fe-protocol3.c:	if (pqGets(&conn->workBuffer, conn))
+fe-protocol3.c:	svname = strdup(conn->workBuffer.data);
+fe-protocol3.c:	if (pqGets(&conn->workBuffer, conn))
+fe-protocol3.c:	extralen = strlen(conn->workBuffer.data);
+fe-protocol3.c:		strcpy(newNotify->extra, conn->workBuffer.data);
+fe-protocol3.c:		if (conn->notifyTail)
+fe-protocol3.c:			conn->notifyTail->next = newNotify;
+fe-protocol3.c:			conn->notifyHead = newNotify;
+fe-protocol3.c:		conn->notifyTail = newNotify;
+fe-protocol3.c:	if (pqGetc(&conn->copy_is_binary, conn))
+fe-protocol3.c:	result->binary = conn->copy_is_binary;
+fe-protocol3.c:	conn->result = result;
+fe-protocol3.c:			conn->xactStatus = PQTRANS_IDLE;
+fe-protocol3.c:			conn->xactStatus = PQTRANS_INTRANS;
+fe-protocol3.c:			conn->xactStatus = PQTRANS_INERROR;
+fe-protocol3.c:			conn->xactStatus = PQTRANS_UNKNOWN;
+fe-protocol3.c:		conn->inCursor = conn->inStart;
+fe-protocol3.c:		avail = conn->inEnd - conn->inCursor;
+fe-protocol3.c:			conn->asyncStatus = PGASYNC_BUSY;
+fe-protocol3.c:				printfPQExpBuffer(&conn->errorMessage,
+fe-protocol3.c:			memcpy(*buffer, &conn->inBuffer[conn->inCursor], msgLength);
+fe-protocol3.c:			conn->inStart = conn->inCursor + msgLength;
+fe-protocol3.c:		conn->inStart = conn->inCursor;
+fe-protocol3.c:	if (conn->sock < 0 ||
+fe-protocol3.c:		conn->asyncStatus != PGASYNC_COPY_OUT ||
+fe-protocol3.c:		conn->copy_is_binary)
+fe-protocol3.c:		printfPQExpBuffer(&conn->errorMessage,
+fe-protocol3.c:	if (conn->asyncStatus != PGASYNC_COPY_OUT)
+fe-protocol3.c:	conn->inCursor = conn->inStart;
+fe-protocol3.c:	avail = conn->inEnd - conn->inCursor;
+fe-protocol3.c:	 * conn->copy_already_done to remember how much of the row was already
+fe-protocol3.c:	conn->inCursor += conn->copy_already_done;
+fe-protocol3.c:	avail = msgLength - 4 - conn->copy_already_done;
+fe-protocol3.c:		memcpy(buffer, &conn->inBuffer[conn->inCursor], avail);
+fe-protocol3.c:		conn->inStart = conn->inCursor + avail;
+fe-protocol3.c:		conn->copy_already_done = 0;
+fe-protocol3.c:		memcpy(buffer, &conn->inBuffer[conn->inCursor], bufsize);
+fe-protocol3.c:		conn->copy_already_done += bufsize;
+fe-protocol3.c:	if (conn->asyncStatus != PGASYNC_COPY_IN &&
+fe-protocol3.c:		conn->asyncStatus != PGASYNC_COPY_OUT)
+fe-protocol3.c:		printfPQExpBuffer(&conn->errorMessage,
+fe-protocol3.c:	if (conn->asyncStatus == PGASYNC_COPY_IN)
+fe-protocol3.c:		if (conn->queryclass != PGQUERY_SIMPLE)
+fe-protocol3.c:	conn->asyncStatus = PGASYNC_BUSY;
+fe-protocol3.c:	resetPQExpBuffer(&conn->errorMessage);
+fe-protocol3.c:	if (conn->errorMessage.len > 0)
+fe-protocol3.c:		char		svLast = conn->errorMessage.data[conn->errorMessage.len - 1];
+fe-protocol3.c:			conn->errorMessage.data[conn->errorMessage.len - 1] = '\0';
+fe-protocol3.c:		pqInternalNotice(&conn->noticeHooks, "%s", conn->errorMessage.data);
+fe-protocol3.c:		conn->errorMessage.data[conn->errorMessage.len - 1] = svLast;
+fe-protocol3.c:		conn->inCursor = conn->inStart;
+fe-protocol3.c:		avail = conn->inEnd - conn->inCursor;
+fe-protocol3.c:			if (pqCheckInBufferSpace(conn->inCursor + msgLength, conn))
+fe-protocol3.c:				conn->inStart += 5 + msgLength;
+fe-protocol3.c:				if (conn->result)
+fe-protocol3.c:				printfPQExpBuffer(&conn->errorMessage,
+fe-protocol3.c:				conn->inStart += 5 + msgLength;
+fe-protocol3.c:		conn->inStart += 5 + msgLength;
+fe-protocol3.c:	 * conn->errorMessage has been set by pqWait or pqReadData. We want to
+fe-protocol3.c:		ProtocolVersion pv = htonl(conn->pversion);
+fe-protocol3.c:	if (conn->pguser && conn->pguser[0])
+fe-protocol3.c:			strcpy(packet + packet_len, conn->pguser);
+fe-protocol3.c:		packet_len += strlen(conn->pguser) + 1;
+fe-protocol3.c:	if (conn->dbName && conn->dbName[0])
+fe-protocol3.c:			strcpy(packet + packet_len, conn->dbName);
+fe-protocol3.c:		packet_len += strlen(conn->dbName) + 1;
+fe-protocol3.c:	if (conn->pgoptions && conn->pgoptions[0])
+fe-protocol3.c:			strcpy(packet + packet_len, conn->pgoptions);
+fe-protocol3.c:		packet_len += strlen(conn->pgoptions) + 1;
+fe-secure.c: *  Set conn->ssl.
+fe-secure.c:	if (conn->ssl == NULL)
+fe-secure.c:		if (!(conn->ssl = SSL_new(SSL_context)) ||
+fe-secure.c:			!SSL_set_app_data(conn->ssl, conn) ||
+fe-secure.c:			!SSL_set_fd(conn->ssl, conn->sock))
+fe-secure.c:			printfPQExpBuffer(&conn->errorMessage,
+fe-secure.c:		resetPQExpBuffer(&conn->errorMessage);
+fe-secure.c:	if (conn->ssl)
+fe-secure.c:	if (conn->ssl)
+fe-secure.c:		n = SSL_read(conn->ssl, ptr, len);
+fe-secure.c:		err = SSL_get_error(conn->ssl, n);
+fe-secure.c:						printfPQExpBuffer(&conn->errorMessage,
+fe-secure.c:						printfPQExpBuffer(&conn->errorMessage,
+fe-secure.c:					printfPQExpBuffer(&conn->errorMessage,
+fe-secure.c:				printfPQExpBuffer(&conn->errorMessage,
+fe-secure.c:		n = recv(conn->sock, ptr, len, 0);
+fe-secure.c:	if (conn->ssl)
+fe-secure.c:		n = SSL_write(conn->ssl, ptr, len);
+fe-secure.c:		err = SSL_get_error(conn->ssl, n);
+fe-secure.c:						printfPQExpBuffer(&conn->errorMessage,
+fe-secure.c:						printfPQExpBuffer(&conn->errorMessage,
+fe-secure.c:					printfPQExpBuffer(&conn->errorMessage,
+fe-secure.c:				printfPQExpBuffer(&conn->errorMessage,
+fe-secure.c:		n = send(conn->sock, ptr, len, 0);
+fe-secure.c:	if (getpeername(conn->sock, &addr, &len) == -1)
+fe-secure.c:		printfPQExpBuffer(&conn->errorMessage,
+fe-secure.c:		pqGethostbyname(conn->peer_cn, &hpstr, buf, sizeof(buf),
+fe-secure.c:		printfPQExpBuffer(&conn->errorMessage,
+fe-secure.c:						  conn->peer_cn, hstrerror(h_errno));
+fe-secure.c:			printfPQExpBuffer(&conn->errorMessage,
+fe-secure.c:		if (pg_strcasecmp(conn->peer_cn, *s) == 0)
+fe-secure.c:			printfPQExpBuffer(&conn->errorMessage,
+fe-secure.c:						 conn->peer_cn, (l >> 24) % 0x100, (l >> 16) % 0x100,
+fe-secure.c:			printfPQExpBuffer(&conn->errorMessage,
+fe-secure.c:							  conn->peer_cn);
+fe-secure.c:		printfPQExpBuffer(&conn->errorMessage,
+fe-secure.c:		printfPQExpBuffer(&conn->errorMessage,
+fe-secure.c:		printfPQExpBuffer(&conn->errorMessage,
+fe-secure.c:		printfPQExpBuffer(&conn->errorMessage,
+fe-secure.c:		printfPQExpBuffer(&conn->errorMessage,
+fe-secure.c:		printfPQExpBuffer(&conn->errorMessage,
+fe-secure.c:		printfPQExpBuffer(&conn->errorMessage,
+fe-secure.c:		printfPQExpBuffer(&conn->errorMessage,
+fe-secure.c:		printfPQExpBuffer(&conn->errorMessage,
+fe-secure.c:			printfPQExpBuffer(&conn->errorMessage,
+fe-secure.c:				printfPQExpBuffer(&conn->errorMessage,
+fe-secure.c:					printfPQExpBuffer(&conn->errorMessage,
+fe-secure.c:	r = SSL_connect(conn->ssl);
+fe-secure.c:		int			err = SSL_get_error(conn->ssl, r);
+fe-secure.c:						printfPQExpBuffer(&conn->errorMessage,
+fe-secure.c:						printfPQExpBuffer(&conn->errorMessage,
+fe-secure.c:					if (conn->errorMessage.len == 0)
+fe-secure.c:						printfPQExpBuffer(&conn->errorMessage,
+fe-secure.c:				printfPQExpBuffer(&conn->errorMessage,
+fe-secure.c:	r = SSL_get_verify_result(conn->ssl);
+fe-secure.c:		printfPQExpBuffer(&conn->errorMessage,
+fe-secure.c:	conn->peer = SSL_get_peer_certificate(conn->ssl);
+fe-secure.c:	if (conn->peer == NULL)
+fe-secure.c:		printfPQExpBuffer(&conn->errorMessage,
+fe-secure.c:	X509_NAME_oneline(X509_get_subject_name(conn->peer),
+fe-secure.c:					  conn->peer_dn, sizeof(conn->peer_dn));
+fe-secure.c:	conn->peer_dn[sizeof(conn->peer_dn) - 1] = '\0';
+fe-secure.c:	X509_NAME_get_text_by_NID(X509_get_subject_name(conn->peer),
+fe-secure.c:							  NID_commonName, conn->peer_cn, SM_USER);
+fe-secure.c:	conn->peer_cn[SM_USER] = '\0';
+fe-secure.c:	if (conn->ssl)
+fe-secure.c:		SSL_shutdown(conn->ssl);
+fe-secure.c:		SSL_free(conn->ssl);
+fe-secure.c:		conn->ssl = NULL;
+fe-secure.c:	if (conn->peer)
+fe-secure.c:		X509_free(conn->peer);
+fe-secure.c:		conn->peer = NULL;
+fe-secure.c:	return conn->ssl;
